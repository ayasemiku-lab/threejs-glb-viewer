<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Three.js GLB Viewer (Import Map)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#0e0e10; color:#ddd; }
    #hud {
      position: fixed; left: 12px; top: 12px; padding: 8px 12px;
      background: rgba(0,0,0,.5); border: 1px solid rgba(255,255,255,.12); border-radius: 8px;
      backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
      font: 14px/1.4 system-ui, sans-serif;
    }
    #progress { width: 240px; height: 6px; background: rgba(255,255,255,.15); border-radius: 999px; overflow: hidden; margin-top: 6px; }
    #bar { height: 100%; width: 0%; background: #fff; transition: width .15s ease; }
    canvas { display:block; }
  </style>

  <!-- “three” という名前をCDN URLにひも付け（examples側の `from 'three'` を解決するため） -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="hud">
    <div><b>GLB Viewer</b> — ドラッグで回転／ホイールでズーム</div>
    <div id="progress"><div id="bar"></div></div>
    <div id="status">Loading…</div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
    // Draco圧縮のGLBなら下2行を有効化し、loaderにセットしてください（そのままでもOK）
    // import { DRACOLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/DRACOLoader.js';

    const statusEl = document.getElementById('status');
    const barEl = document.getElementById('bar');
    const setStatus = (t) => statusEl.textContent = t;

    // レンダラー
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // シーン
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e0e10);

    // カメラ
    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 2000);
    camera.position.set(2.5, 1.6, 3.5);

    // コントロール
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ライティング（見えること最優先でやや明るめ）
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.4);
    dir.position.set(5, 8, 5);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    // 影受け用の薄い床
    const groundGeo = new THREE.CircleGeometry(10, 64);
    const groundMat = new THREE.ShadowMaterial({ opacity: 0.25 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // GLBローダー
    const loader = new GLTFLoader();
    // Draco対応サンプル（圧縮モデルを使う場合のみ）
    // const draco = new DRACOLoader();
    // draco.setDecoderPath('https://unpkg.com/three@0.165.0/examples/jsm/libs/draco/');
    // loader.setDRACOLoader(draco);

    // 進捗
    const onProgress = (xhr) => {
      if (xhr.total) {
        const p = (xhr.loaded / xhr.total) * 100;
        barEl.style.width = p.toFixed(0) + '%';
        setStatus(`Loading… ${p.toFixed(0)}%`);
      } else {
        setStatus('Loading…');
      }
    };

    // 読み込み
    let mixer = null;
    loader.load(
      // ★ここをあなたのファイルに合わせてください
      'assets/model.glb',
      (gltf) => {
        setStatus('Loaded ✓');
        barEl.style.width = '100%';

        const root = gltf.scene;
        root.traverse((o) => {
          if (o.isMesh) {
            o.castShadow = true;
            o.receiveShadow = true;
            if (o.material?.isMeshStandardMaterial) {
              o.material.envMapIntensity = 1.0;
            }
          }
        });

        // 原点合わせ & スケール調整
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);
        root.position.sub(center);

        const maxDim = Math.max(size.x, size.y, size.z);
        const targetSize = 2.0; // 最大辺を2程度に収める
        const scale = maxDim > 0 ? targetSize / maxDim : 1.0;
        root.scale.setScalar(scale);

        scene.add(root);

        // アニメーションがある場合は再生
        if (gltf.animations?.length) {
          mixer = new THREE.AnimationMixer(root);
          gltf.animations.forEach((clip) => mixer.clipAction(clip).play());
        }

        // カメラをモデルに合わせてリフレーミング
        const newBox = new THREE.Box3().setFromObject(root);
        const newCenter = new THREE.Vector3();
        const newSize = new THREE.Vector3();
        newBox.getCenter(newCenter);
        newBox.getSize(newSize);
        const newMax = Math.max(newSize.x, newSize.y, newSize.z);
        const fov = camera.fov * (Math.PI / 180);
        const dist = Math.abs(newMax / 2 / Math.tan(fov / 2));
        camera.position.set(newCenter.x + dist * 0.6, newCenter.y + dist * 0.6, newCenter.z + dist * 1.2);
        controls.target.copy(newCenter);
        controls.update();
      },
      onProgress,
      (err) => {
        console.error('モデル読み込みエラー:', err);
        setStatus('モデル読み込みエラー。パスやCORSを確認してください。');
      }
    );

    // ループ
    const clock = new THREE.Clock();
    function tick() {
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();

    // リサイズ
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>