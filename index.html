<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>3モデル ギャラリー</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
    }
  }
  </script>

  <style>
    body { margin:0; font:14px/1.5 system-ui, sans-serif; background:#0e0e10; color:#ddd; }
    h1 { text-align:center; padding:20px 0; }
    .gallery {
      display: grid;
      grid-template-columns: repeat(3, 1fr); /* 常に3列 */
      gap: 16px;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px 40px;
    }
    glb-viewer {
      aspect-ratio: 16/9;
      border-radius: 12px;
      overflow: hidden;
      background: #0e0e10;
    }
  </style>
</head>
<body>
  <h1>GLB モデルギャラリー</h1>

  <!-- メンテ注意：実際にはそれぞれの行に違うモデルを入れる感じです -->
  <main class="gallery">
    <glb-viewer src="assets/model.glb" autorotate></glb-viewer>
    <glb-viewer src="assets/model.glb" exposure="1.2"></glb-viewer>
    <glb-viewer src="assets/model.glb"></glb-viewer>
  </main>

  <!-- Web Component定義（昨日のglb-viewerクラスをそのまま使う） -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';

    class GlbViewer extends HTMLElement {
      static get observedAttributes() { return ['src','autorotate','exposure','bg']; }
      constructor(){
        super();
        this.attachShadow({mode:'open'});
        const style=document.createElement('style');
        style.textContent=`:host{display:block;contain:content;}
          canvas{display:block;width:100%;height:100%}`;
        this.shadowRoot.append(style);

        this.renderer=new THREE.WebGLRenderer({antialias:true});
        this.renderer.setPixelRatio(Math.min(devicePixelRatio,2));
        this.renderer.outputColorSpace=THREE.SRGBColorSpace;
        this.shadowRoot.append(this.renderer.domElement);

        this.scene=new THREE.Scene();
        this.camera=new THREE.PerspectiveCamera(45,1,0.1,2000);
        this.camera.position.set(2.5,1.6,3.5);
        this.controls=new OrbitControls(this.camera,this.renderer.domElement);
        this.controls.enableDamping=true;
        this.scene.add(new THREE.HemisphereLight(0xffffff,0x222233,1.0));
        this.scene.add(new THREE.AmbientLight(0xffffff,0.6));
        this.loader=new GLTFLoader();
        this.clock=new THREE.Clock();
        this._resizeObserver=new ResizeObserver(()=>this._resize());
        this._resizeObserver.observe(this);
      }
      connectedCallback(){ this._resize(); this._render(); if(this.getAttribute('src')) this._load(this.getAttribute('src')); }
      attributeChangedCallback(n,o,v){ if(n==='src'&&v) this._load(v); if(n==='autorotate') this.controls.autoRotate=this.hasAttribute('autorotate'); if(n==='exposure') this.renderer.toneMappingExposure=parseFloat(v)||1.0; if(n==='bg') this.scene.background=new THREE.Color(v); }
      _load(url){
        this.loader.load(url,(gltf)=>{
          if(this._root) this.scene.remove(this._root);
          this._root=gltf.scene;
          this.scene.add(this._root);
          const box=new THREE.Box3().setFromObject(this._root);
          const center=new THREE.Vector3(); box.getCenter(center); this._root.position.sub(center);
          const size=new THREE.Vector3(); box.getSize(size); const maxDim=Math.max(size.x,size.y,size.z);
          const fov=this.camera.fov*Math.PI/180; const dist=Math.abs(maxDim/2/Math.tan(fov/2));
          this.camera.position.set(center.x+dist*0.6,center.y+dist*0.6,center.z+dist*1.2);
          this.controls.target.copy(center); this.controls.update();
        });
      }
      _resize(){ const rect=this.getBoundingClientRect(); this.renderer.setSize(rect.width,rect.height,false); this.camera.aspect=rect.width/rect.height; this.camera.updateProjectionMatrix(); }
      _render(){ this.controls.update(); this.renderer.render(this.scene,this.camera); requestAnimationFrame(()=>this._render()); }
    }
    customElements.define('glb-viewer',GlbViewer);
  </script>
</body>
</html>
